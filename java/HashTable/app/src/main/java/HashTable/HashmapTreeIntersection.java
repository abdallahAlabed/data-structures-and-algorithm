package HashTable;

public class HashmapTreeIntersection<S, T> {
//    public BinarySearchTree[] hashTable = new BinarySearchTree[10];
//
//    public int hash(S key) {
//        int sum = 0;
//        char[] charArr = key.toString().toCharArray();
//        for (int oneChar : charArr) {
//            sum += oneChar;
//        }
//        return sum % hashTable.length;
//    }
//
//    public void add(S key, T data) {
//        int index = hash(key);
//        hashTable[index].add((S)key, data);
//
//    }
//
//    public T get(S key) {
//        int index = hash(key);
//
//        if (hashTable[index] == null) {
//            return null;
//        } else {
//            return (T) hashTable[index].getValFoNod(key).data;
//        }
//
//    }
//
//    public boolean contains(S key) {
//        int index = hash(key);
//
//        if (hashTable[index] == null) {
//            return false;
//        } else
//            return hashTable[index].contains(key);
//
//
//    }

//    public S printOneBucket(S key) {
//        int index = hash(key);
//
//        if (hashTable[index] == null) {
//            return null;
//        } else
//            return (S) hashTable[index].toString();
//    }

}
